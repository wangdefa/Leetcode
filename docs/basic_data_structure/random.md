## Random

[TOC]

In this part, we will focus on the random algorithm, such as shuffle, reservoir sample problems and weighted reservoir sample problems.

---

### Shuffle

#### Problem description

给定一组数据，给出这组数据的一个随机排列(**排列问题**)。  
eg.  
　　input: {1, 3, 2, 5}   
　　output can be: {2, 3, 1, 5} or {5, 2, 1, 3}...

#### Algorithm description and certification

假设输入为： $arr[n]$, 那么可以有如下算法：

  ```c++
  for i = 1 ~ n:
    j = rand() % (n - i + 1)
    swap(arr[j], arr[n - i])
  ```

  1. 当$i=1$时，随机数$j\in[0,n)$, 那么有： $p(j)=\frac{1}{n}$ 

  2. 交换$arr[j]$与$arr[n-i]$, 从而将$arr[j]$作为洗出来的第一张牌放在最后，从而得知，每一张牌放在最后的概率均为$p(j)=\frac{1}{n}$；

  3. 在第$i$轮循环中，选中了最初数组当中的元素k，那么有：
     $$
     p(k)=\frac{1}{n-i+1}\times\prod_{j=0}^{i-2}\frac{n-j-1}{n-j}=\frac{1}{n}
     $$
     

#### Code

```cpp
void Shuffle(std::vector<uint32_t> *src) {
  srand((unsigned)time(NULL));
  const uint32_t sz = src->size();
  for (std::size_t i = 0; i < sz; i++) {
    uint32_t r = rand() % (sz - i);
    uint32_t tmp = (*src)[r];
    (*src)[r] = (*src)[sz - i - 1];
    (*src)[sz - i - 1] = tmp;
  }
}
```

#### Reference

[Data structure and algorithm lintcode/leetcode](https://algorithm.yuanbin.me/zh-hans/basics_algorithm/probability/shuffle.html)

---

### Reservoir Sample

#### Problem description

给定一组数据，从中进行不放回的随机抽取$k$个数(**组合问题**)，下面是wikipedia给出的解释。  

> **Reservoir sampling** is a family of [randomized algorithms](https://en.wikipedia.org/wiki/Randomized_algorithm) for randomly choosing a [sample](https://en.wikipedia.org/wiki/Sampling_(statistics)) of *k* items from a list *S* containing *n* items, where *n* is either a very large or unknown number. Typically *n* is large enough that the list doesn't fit into [main memory](https://en.wikipedia.org/wiki/Main_memory). 

　　eg.  
	input: {$1, 3, 2, 5$}，　$k = 2$;   
　　output can be: {$2, 3$} or {$1, 3$}...

#### Algorithm description and certification

假设输入为：　$arr[sz]$, $k$, 并且${k}\leq{sz}$可以有如下算法：

```cpp
// initialize
assert(k <= sz);
res[0:k] = arr[0:k]; // 区间为：　[0, k)
for (i = k; i < sz; i++)
  r = rand() % (i + 1);
  if (r < k)
    res[r] = arr[i];
```

1. 若 $sz=k$, 那么初始化会搞定这个问题，即每个元素都会被选中;

2. 若 $sz=(k+1)$, 那么当 $i=k$时，新元素被加入到结果当中的概率为：$\frac{k}{sz}$, 已经放入结果当中的元素继续存在于结果当中的概率也为：$\frac{k}{sz}$;

3. 当 $sz>\left(k+1\right)$, 同理可以推出上述结果。
   eg:
   当 $sz=k+2$时，新元素被加入的概率为：$\frac{sz-2}{sz}$； 前$n-1$个元素中的某一个$j$仍然存在的概率为：
   $$
   \begin{equation}
   \begin{aligned}
   p(j) &= \frac{k}{k+1}\times\frac{k+1}{k+2}\\
   &=\frac{k}{k+2}\\
   &=\frac k sz
   \end{aligned}
   \end{equation}
   $$
   

整个算法的时间复杂度为： **O(sz)**.

#### Code

```cpp
void AlgorithmR() {
  res.clear();
  m_res.resize(m_k);
  assert(m_k < m_data.size() && "Invalid sampling problem here.");
  // Initialize
  for (uint32_t i = 0; i < m_k; i++) {
    res[i] = m_data[i];
  }
  // Load data from the disk and update the Node(data) in the pool
  srand((unsigned)time(NULL));
  for (uint32_t i = m_k; i < m_data.size(); i++) {
    uint32_t r = rand() % (i + 1);
    if (r < m_k) {
      res[r] = m_data[i];
    }
  }
}
```

#### Reference

Also, there are some other extension of the sampling algorithm, just like **weighted sampling algorithm**(maybe we can use it in some machine learning algorithm, such as **bagging**, etc), you can refer to [Wikipedia](https://en.wikipedia.org/wiki/Reservoir_sampling) for more information.
Besides, we can use **priority queue** to maintain top k minimum element(the key for the priority queue is generated by a random distribution). The run time of the algorithm is $sz \times \log(k)$, although it is slower than the first algorithm, bu we can extend it to weighted reservoir sample problem easily.

---

### Weighted Reservoir Sample

#### Problem description

若给定一组$size$(query的个数)未知的搜索query(数量可能非常多)，每个query对应了一个搜索频次$frequency$(在此称之为$weight$)， 当前的任务为：按照query的搜索频次($weight$)返回$k$个样本(不放回的抽样)。
eg:
	input query: {{"a", 1}， {"b", 2}, {"c", 3}, {"d", 4}};
	input k:	    3;
	若设“a”被抽中的概率为$p(a)$, 那么每个样本被抽中的概率需要满足以下关系：
$$
p(a)=min(1.0, p(b)\times \frac {w_a} {w_b})=min(1.0, \frac {p(b)}{2})
$$
对于上述例子，可以很容易得到：
$$
\begin{equation}
\begin{aligned}
&p(a)= {3}/{10}\\
&p(b)= {6}/ {10}\\
&p(c)= {9}/ {10}\\
&p(d)= {10}/ {10}
\end{aligned}
\end{equation}
$$


#### Algorithm description and certification

设第$i$个query的搜索频次为$w_i$, 整个query的个数为$size$, 需要从中抽取$k$个（采用一个优先级队列p_queue来存储），那么我们可以有以下伪代码([Algorithm A-Res](https://en.wikipedia.org/wiki/Reservoir_sampling#Weighted_Random_Sampling_using_Reservoir))：

```pseudocode
for each i = [0, size):
	// rand(0, 1): 生成一个[0,1]之间服从均匀分布的随机数
	n_wi = rand(0, 1) ^ (1/wi); 
	if i < k:
		p_queue.insert(i, n_wi); // n_wi为优先级队列的key
	else:
		(j, n_wj) = p_queue.getMin();
		if n_wj < n_wi:
			// 使用i来替换j
			p_queue.popMin(); 
			p_queue.insert(i, n_wi);
```

* Proof

  采用数学归纳法证明：

  1. 当$k=1$时，对于任意两个元素$i, j \in [0, size)$，设在计算$n\_w_i, n\_w_j$时生成的随机数分别为$r_i， r_j$, 那么有：
     a. 当$size=2$时， $i=0, j= 1$：
     $$
     \begin{equation}
     \begin{aligned}
     p(i)&=p(n\_w_i>n\_w_j)=p(r_i^{\frac{1}{w_i}}>r_j^{\frac{1}{w_j}})\\
     &=p(r_i>r_j^{\frac{w_i}{w_j}})\\
     &=1-\int_{ 0 }^{ 1 } {r_j^{\frac{w_i}{w_j}}dr_j} \\
     &=
     \left.1-\frac{1}{1+\frac{w_i}{w_j}} \times r_j ^{1+\frac{w_i}{w_j}}\right|_0^1\\
     &=\frac{w_i}{w_i+w_j}
     \end{aligned}
     \end{equation}
     $$
     

     上式说明，对于任意两个元素$i, j$, 其最终被抽中的概率: $p(i) \propto {w_i} $

     > 对于公式当中转换为定积分的那一步，如果不清楚的话，可以直接画一个草图，然后便可得知求定积分的几何意义。

     b. 当$size=3$时，设第三个元素为$k$, 将上述的一重积分扩展到二重积分(有一点复杂，推荐自己画图试一下)，同理可以证明: $p(i) \propto {w_i} $
     $$
     \begin{equation}
     \begin{aligned}
     p(i)&=p(n\_w_i>n\_w_j \and n\_w_i>n\_w_k)\\
     &=p(r_i>r_j^{\frac{w_i}{w_j}} \and r_i>r_k^{\frac{w_i}{w_k}})\\
     &=\int_{ 0 }^{ 1 } {r_i^{\frac{w_j}{w_i}}} \times  {r_i^{\frac{w_k}{w_i}}} dr_i \\
     &=\frac{w_i}{w_i+w_j+w_k}
     \end{aligned}
     \end{equation}
     $$

  2. 当$k=2$时，我们可以看成是先取出一个元素，然后删除此元素； 鉴于剩下的元素在生成权重$r_i$时仍然满足独立同分布，那么可以直接从中选出第二大$n\_w_i$所对应的元素，即得到最后的解； 同理可以推出$k=3$等等。

#### Code

```cpp
void AlgorithmARes() {
  // AlgorithmARes:
  //  it is a sampling algorithm which takes the weight into consideration
  // Initialize
  m_res.clear();
  assert(m_k < m_data.size() && "Invalid sampling problem here.");
  for (uint32_t index = 0; index < m_k; index++) {
    double r_i =
        pow(rand() / double(RAND_MAX), 1 / double(m_data[index].weight));
    m_res.push_back(Node(r_i, m_data[index].val));
  }
  std::make_heap(m_res.begin(), m_res.end());
  
  // Update
  for (uint32_t index = m_k; index < m_data.size(); index++) {
    double r_i =
        pow(rand() / double(RAND_MAX), 1 / double(m_data[index].weight));
    if (r_i > m_res.front().weight) {
      std::pop_heap(m_res.begin(), m_res.end());  // delete operation of heap
      m_res.pop_back();  // we use the vector to delete
      m_res.push_back(Node(r_i, m_data[index].val));
      std::push_heap(m_res.begin(), m_res.end());
    }
  }
}
```

Below is the test result of the afore mentioned two algorithms. Please notice the result of algorithm A-Res, it may be a little different from what you think, since there is a truncate error when we using the  probility.

```shell
$ ./basic_data_structure/random 	
Input entry and it's weight:
Entry & weight	a(8)	b(3)	c(3)	d(1)	e(7)	f(7)	g(2)	h(3)	i(6)	j(10)	
AlgorithmR	   0.0993	0.0999	0.10058	0.10017	0.09958	0.09938	0.1004	0.10062	0.09983	0.10024	
AlgorithmA-Res	0.14395	0.07394	0.07367	0.02743	0.13572	0.13467	0.05405	0.074	0.12375	0.15882
```



#### Reference

[Weighted_Random_Sampling_using_Reservoir](https://en.wikipedia.org/wiki/Reservoir_sampling#Weighted_Random_Sampling_using_Reservoir)

[概率加权的随机抽样 (Weighted Random Sampling) – A-Res 蓄水池算法](http://live.aulddays.com/tech/17/weighted-random-sampling-reservoir-algorithm.htm)